---
layout:     posts
title:      Angular Twitter Clone
date:       2016-03-08
thumbnail:  sass.png
assets:     /assets/post-assets/11-angular-twitter-clone/
categories: work
tags:       javascript angular firebase
---
Okay so maybe not EXACTLY a twitter clone but that's not the point. I wanted to build a quick app and some sort of twitter/text based posting app is what came to mind

## Starting point
I love gulp, I use it for everything and this was no exception. My gulp process compiles my SASS, and I also use it to concatenate my javascript files into one so I only had to have one script tag to import the code I wrote. This isn't necessary the best way to do things when debugging because error messages only point to one file instead of pointing to the specific file where the error occurred, but this was a small project just for some experience so I could live with it.

### It has to look nice
I started by creating basic styles to give everything I might need a similar look and feel, like how I designed the buttons and input forms. For the styles I used SASS with the Bourbon and Neat mixin libraries just to make things quick and easy. I used the same SASS architecture for this project that I described in my last post, [here]({% post_url 2016-02-23-css-architecture-and-semantics %}).

### Angular Templates
I created a basic HTML document to structure the application and to layout the components I was going to use. Things like the login/register forms and the nav bar. I then broke these components up into their own view template files. I used a ng-include directive to pull in the nav.html template since it is a constant on each page. Next I have a main element with a ng-view that the main components of the app will be loaded into depending on the page the user is on.

### Angular MVC
Now getting into angular's magic. In my app.js file I declare an angular module named "myApp" (great name I know) that uses the ngRoute and firebase dependancies. Then in the module config I use $routeProvider to setup templates and controllers that will be used for what page the user is on, even though there's really only one page just the content of the page get's changed.

{% highlight javascript %}
myApp.config(['$routeProvider', function($routeProvider) {
  $routeProvider.
    when('/login', {
      templateUrl: 'views/login.html',
      controller: 'RegistrationController' //created later
    }).
    when('/register', {
      templateUrl: 'views/register.html',
      controller: 'RegistrationController' //created later
    }).
    otherwise({
      redirectTo: '/login'
    });
}]);
{% endhighlight %}

Now we can go to the /login page and see the login form or the /register page to see the register form. If the user tries to access any other page they are just redirected to the /login page.

## Firebase Authentication

### Login/Registration
<!-- Page Routes/MVC -->

When a user registers their information is first stored in Firebase's authentication but also as a data object to be used by the app. Firebase's user auth and login service stores the user email, date created, and unique user UID hash. The users password is never accessible but there are functions for reseting it.

I created an angular service to handle authentication. In the service I declare an object to hold the methods used for login and registration. The registration method takes the data the user inputs into the register form and uses the Firebase $createUser function to create the new user.

{% highlight javascript %}
register: function(user) {
  auth.$createUser({
    email: user.email,
    password: user.password
  })...
} //register method
{% endhighlight %}

After the user is created created we get a promise back from Firebase, here we can store the rest of the user data in an object using the Firebase .set method that we key using the unique key generated by Firebase for that user __"regUser: regUser.uid,"__. After the user data is stored we also catch any errors that might occur, like if the email has already been registered.

{% highlight javascript %}
register: function(user) {
  //create firebase user, pass it an object of user info
  auth.$createUser({
    email: user.email,
    password: user.password
  }).then(function(regUser) { //callback promise from firebase

    //when the user is register, store their info as an object
    var regRef = new Firebase(FIREBASE_URL + 'users')
      .child(regUser.uid).set({
        date:      Firebase.ServerValue.TIMESTAMP,
        regUser:   regUser.uid,
        firstname: user.firstname,
        lastname:  user.lastname,
        email:     user.email
      }); //user info

    myObject.login(user);
  }).catch(function(error) { //catch any errors from firebase (email already registered)
    $rootScope.message = error.message;
  }); //auth.createUser()
} //register method
{% endhighlight %}

The user data that gets store is structured like this:

{% highlight json %}
{
  "users": {
    "0f0089bd-5ac8-4cd8-b2cc-346446a02ba0": {
      "firstname": "Derek",
      "lastname":  "Morash",
      "email":     "derek.morash@gmail.com",
      "date":      1457233194399, /*Server Value from firebase*/
      "regUser":   "0f0089bd-5ac8-4cd8-b2cc-346446a02ba0"
    },
    "a33d273e-2a3f-42a0-bfaa-a66638b6ab1b": {
      "firstname": "Carl",
      "lastname":  "Sagan",
      "email":     "carl.sagan@gmail.com",
      "date":      1458230984893, /*Server Value from firebase*/
      "regUser":   "a33d273e-2a3f-42a0-bfaa-a66638b6ab1b"
    }
  }
}
{% endhighlight %}

### Authentication Service
<!-- Angular Service -->
<!-- making sure a user is logged in -->

## The "Tweets"

### Data Structure


<!-- Putting tweets inside the user objects? -->
<!-- NO! Creating a tweet object -->




{% highlight json %}
{
  "users": {...},
  "tweets" : {
    "-KC9s551uW1H9ZCuSGjN" : {
      "date" : 1457250132514, /*server value from firebase*/
      "tweet" : "This is a tweet",
      "userID" : "0f0089bd-5ac8-4cd8-b2cc-346446a02ba0"
    },
    "-KC9zn9JADSrxL4i1I3Y" : {
      "date" : 1457252152016, /*server value from firebase*/
      "tweet" : "This is another tweet",
      "userID" : "0f0089bd-5ac8-4cd8-b2cc-346446a02ba0"
    },
  }
}
{% endhighlight %}

### Adding and Retrieving Data (Tweets)

{% highlight javascript %}
ref.child('tweets').on('value', function(snapshot) {
  //init an array to hold the tweets
  var tweetFeed = [];
  //loop through the list of tweets
  snapshot.forEach(function(childSnapshot) {
    //store the userID for each tweet
    var nextTweet = childSnapshot;
    //get the user based on the userID
    ref.child('users/' + nextTweet.val().userID).once('value', function(snapshot) {
      //join the tweet and the user
      var singleTweet = {
        userID: snapshot.key(),
        user: snapshot.val().firstname,
        tweet: nextTweet.val().tweet,
        tweetKey: nextTweet.key(),
        date: nextTweet.val().date
      };
      //add the data to the array we initialized
      tweetFeed.push(singleTweet);
    });
  });
  $scope.tweetFeed = tweetFeed;
});
{% endhighlight %}

### Next Steps
<!-- adding delete and edit on tweets -->
I need to add more CRUD functionality to the app. Users should be able to delete and edit their tweets. My first idea for this was to just only display the delete and edit buttons when that specific tweet belonged to the logged in user using the ngShow directive. The problem with this is that the buttons still exist in the markup, they are only being hidden, so anyone could inspect the element and remove that ngShow directive and be able to delete a tweet that doesn't belong to them. I need to think of a way to create the buttons ONLY if they belong to the person logged in instead of simply hiding them.

<!-- maybe adding user control like changing passwords/deleting account -->
Another thing I'd like to add is the ability for users to update their account info or delete their accounts. This simply means going through Firebase's documentation and tutorials, but I think the CRUD actions are more a higher priority.
